## MVCC (다중 버전 동시성 제어)
`MVCC(Multi-Version Concurrency Control)`는 동시 접근을 허용하는 DB에서 `동시성을 제어`하기 위해 사용하는 방법 중 하나로, `스냅샷`을 통해 하나의 레코드에 대해 `여러 버전`을 관리한다.

원본 데이터와 변경 중인 데이터를 동시에 유지하여
- 변경이 취소(`Rollback`)되면, 원본 스냅샷을 바탕으로 데이터를 복구하고
- 변경이 완료(`Commit`)되면, 최종적으로 디스크에 반영한다.
또한, 트랜잭션의 격리수준을 보장할 수 있다.

`MVCC`를 이용하는 이유는 `락을 사용하지 않기 위해`서다.
- 동시성 제어를 위한 가장 쉬운 방법은 `Lock`이지만, 속도가 떨어진다.
- 따라서, MySQL은 MVCC를 사용하며, 스냅샷으로 `Undo Log`를 활용한다.

## Undo Log
`Undo 로그`는 `변경 전의 데이터를 관리`하여 MySQL의 `트랜잭션과 격리 수준을 보장`한다.
- 트랜잭션 보장 : 트랜잭션이 롤백되면 데이터를 백업된 이전 버전으로 복구
- 격리 수준 보장 : 특정 트랜잭션에서 데이터 변경하는 도중에, 다른 트랜잭션이 데이터를 조회하면 격리 수준에 맞는 데이터 반환

![](https://i.imgur.com/k3esawK.png)

``` sql
update account set balance = 8000 where id = 1;
```

위의 update 문을 실행하면 commit 여부와 무관하게 `InnoDB 버퍼풀`은 새로운 값으로 갱신한다.  
그리고, 이전의 데이터를 `Undo 로그`에 담아둔다.

![](https://i.imgur.com/iQM4eYt.png)

이 때, 트랜잭션 도중 오류가 발생하여 `Rollback`이 발생하면, Undo 로그를 참조해서 이전 상태로 되돌린다.   

또한, 아직 Commit이나 Rollback이 호출되지 않는 상태에서 다른 사용자가 id = 1을 조회한다면?
- 트랜잭션 격리수준에 따라 다르다
- `Read Uncommitted` : 버퍼풀의 새로운 데이터를 반환
- `Read Commited` 이상 : 변경되기 이전의 Undo 로그의 데이터를 반환

<br> 

**Undo 로그의 동작 방식은 다음과 같은 상황에서는 좋지 않다.**
- 대량의 데이터를 변경 또는 삭제하는 경우
	- 수십만 건을 한번에 삭제하면, 각 row마다 삭제 전 상태를 Undo 로그에 저장
- 트랜잭션을 오래 유지하는 경우
	- 트랜잭션이 열려있는 동안 Undo 로그는 삭제되지 않음 -> 메모리 사용량 증가

<br>

## Redo Log
`Redo Log`는 데이터 변경 시 해당 변경 내용을 기록하여, **ACID의 영속성(Durability)** 을 보장한다.
- 커밋 완료 후 아직 디스크에 아직 반영되지 않은 시점에 DB 서버가 비정상 종료되면,
- DB 재시작 시 `Redo Log`를 이용해 변경 내용을 디스크에 적용하여 영속성을 보장한다.

<br>

즉, `Redo Log`는 **장애 복구 시 커밋된 변경 사항을 재적용**하는데 사용된다.
