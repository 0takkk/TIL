## 인덱스

데이터 레코드를 빠르게 접근하기 위해서 <키, 포인터> 쌍으로 구성되는 데이터 구조이다.

- `조회 성능 향상`에 이점이 있지만,
- 인덱스를 위한 테이블 크기의 10% 정도의 `공간이 추가로 필요`하고,
- Insert, Update, Delete가 자주 발생한다면 `인덱스 정렬 작업으로 인해 성능이 하락`한다.

## 종류

`클러스터 인덱스(Clustered Index)`와 `비클러스터(보조) 인덱스(non-Clustered Index, Secondary Index)`가 존재한다.

- `클러스터 인덱스(Clustered Index)`
  - 테이블의 실제 데이터가 인덱스에 포함된 형태
  - 즉, 리프 노드에 `데이터 자체`가 저장되어 있기 때문에, 인덱스를 따라가면 바로 데이터를 읽을 수 있다.
  - 한 테이블에 하나만 생성 가능하다.
  - InnoDB에서는 기본키(Primanry Key)에 대해 자동으로 클러스터형 인덱스가 생성된다.
- `비클러스터 인덱스(non-Clustered Index, Secondary Index)`

  - 클러스터형 인덱스가 아닌 다른 컬럼들에 대해 생성된 인덱스이다.
  - 한 테이블에 여러개 설정 가능하다.
  - 리프 노드에 해당 행의 PK만 저장되며
  - 데이터를 실제로 조회하려면 PK를 이용해 클러스터 인덱스를 따라가야 한다.

## 인덱스 동작 원리

클러스터 인덱스와 보조 인덱스 모두 내부적으로 `균형 트리(B+Tree)`로 구성된다.  
균형 트리 구조에서 데이터가 저장되는 공간을 `노드`라고 한다.  
노드는 위치에 따라 루트 노드, 중간 도드, 리프 노드로 구성된다.  
MySQL에서는 이러한 노드들을 `페이지`라고 한다.  

데이터 검색 시 루트 페이지에서 검색할 데이터가 몇 번 페이지에 있는지 탐색하고, 해당 페이지를 확인하여 데이터를 추출한다.  
MySQL에서는 최소 16KB 크기로 페이지를 구성하며, 추가적인 공간이 필요할 경우 `페이지 분할 작업을 통해 페이지를 생성하고 각 페이지에 데이터를 분할하는 작업`을 거친다.  

### 페이지 분할

![](https://i.imgur.com/b4vUrcI.png)

- 인덱스를 구성하면 데이터 변경 작업(Insert, Update, Delete) 시 성능이 나빠진다.
- 특히, Insert의 영향이 큰데, `페이지 분할 작업`이 발생하기 때문이다.
- 페이지 분할이란, 데이터를 페이지 단위로 저장하는 기본 구조에서 추가적인 페이지가 필요할 때, 새로운 페이지를 준비하여 데이터를 나누는 작업을 말한다.
- 페이지 분할 작업이 자주 일어나면 데이터베이스 성능에 큰 영향을 미친다.

### 클러스터 인덱스 페이지 구조

![](https://i.imgur.com/MjJps43.png)

- 클러스터 인덱스가 걸린 PK를 기준으로 실제 데이터가 정렬된다.
- `루트 페이지`, `중간 페이지`에는 <key, value>로 <PK, `페이지번호`>를 가지고 있다.
- `리프 페이지`는 <key, value>로 <PK, `실제 데이터`>를 가지고 있다.
- 클러스터 인덱스를 통해 select하면 루트 페이지에서 탐색할 페이지를 찾고, 해당 페이지에서 검색할 데이터를 찾게 되어, 검색 시간을 줄이게 된다.

<br>

### 보조 인덱스 페이지 구조

![](https://i.imgur.com/PPeYrXn.png)

- 보조 인덱스 페이지는 실제 데이터를 정렬하지 않는다.
  - `별도의 공간에 정렬된 인덱스 페이지를 생성하고 관리`한다.
- 또한, 실제 데이터를 가지고 있지 않다!
- `인덱스 페이지`와 `데이터 페이지`가 구분 되어 있다.
- `루트 페이지`는 클러스터 인덱스와 마찬가지로 컬럼에 대한 `페이지 번호`를 가지고 있다.
- `리프 페이지`에는 실제 데이터를 갖지 않고, `데이터 페이지 번호 + 오프셋`을 가지고 있다.
  - 따라서, 실제 데이터에 접근하기 위해서는 인덱스 페이지에서 데이터 페이지로 이동해야 한다.

<br>

### 클러스터 인덱스와 보조 인덱스 혼합

현실적으로 하나의 테이블에 클러스터 인덱스와 보조 인덱스가 혼합되어 있는 경우가 많다.  
PK는 기본적으로 존재하고, `조회가 많이 발생하는 컬럼에 대해 인덱스를 추가`하기 때문이다.  

이 경우, `보조 인덱스를 먼저 거치고, 이어 클러스터 인덱스를 거쳐 데이터를 찾는다`.  
![](https://i.imgur.com/mEB2XLF.png)

- `rank` 컬럼을 PK로 지정하고, `language` 컬럼에 보조 인덱스를 생성되어 있다.  
- 보조 인덱스의 리프 노드에는 `데이터 페이지 번호 + 오프셋` 대신 `rank(PK)` 컬럼 값을 가지고 있다.  
- `rank` 값을 가지고 클러스터 인덱스를 탐색하게 된다.  

<br>

### **혼합 구조에서 보조 인덱스에 PK값을 가지고 있는 이유**

- 테이블에 데이터가 추가, 수정, 삭제되면 테이블 데이터의 페이지 번호와 페이지 내 순서가 모두 변경된다.  
- 보조 인덱스가 `데이터 페이지 번호 + 오프셋` 정보를 가지고 있다면, 데이터 변경 때 값을 모두 수정해야한다.  
- 따라서, 혼합 인덱스 구조에서는 보조 인덱스가 PK를 가지고 있다.


<br> 

---

**참고 자료**
- https://hudi.blog/db-clustered-and-non-clustered-index/
- https://velog.io/@sweet_sumin/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%93%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4-Clustered-Index-%EB%84%8C-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%93%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4-Non-Clustered-Index
