## 트랜잭션
`트랜잭션`은 `데이터베이스에서 하나의 논리적인 작업 단위`로, `모두 성공하거나 모두 실패해야 하는 특성`을 가진다.  
`트랜잭션`은 아래의 `ACID 원칙`을 기반으로 동작한다.  
- `Atomicity (원자성)` : 모든 작업이 성공해야만 DB에 반영되고, 하나라도 실패하면 모든 작업을 취소해야 한다.
- `Consistency (일관성)` : 트랜잭션 수행 후에도 DB의 제약조건은 항상 만족되어야 한다.
- `Isolation (격리성)` : 동시에 실행되는 트랜잭션은 서로 간섭 없이 독립적으로 실행되어야 한다.
- `Durability (지속성)` : 커밋된 트랜잭션의 결과는 시스템 장애가 발생하더라도 영구적으로 저장되어야 한다.

<br>

### 지속성(Durabuility)은 어떻게 보장되나?
DBMS는 트랜잭션이 커밋되기 전, 변경 내용을 `Redo Log`에 먼저 기록한다.  
장애가 발생해도 `Redo Log`를 이용하여 트랜잭션 결과를 복구할 수 있다.

<br>

### 트랜잭션 격리 수준
트랜잭션 간 `동시성 제어 수준`을 설정하는 것으로, 트랜잭션 간의 간섭을 어느 수준까지 허용할지를 결정한다.
- `Read Uncommitted`: 커밋되지 않은 데이터를 읽을 수 있음 (Dirty Read 가능)
- `Read Committed` : 커밋된 데이터만 읽을 수 있음 (Non-repeatable Read, Phantom Read 가능)
- `Repeatable Read` : 같은 트랜잭션 내에서 같은 데이터를 반복 조회하면 항상 같은 결과 (Phantom Read 가능)
- `Serializable` : 트랜잭션이 완료될 때까지 그 영역에 해당되는 데이터에 접근이 불가능

<br>

### 읽기 작업에 트랜잭션을 걸어야 할까?
일반적으로는 단순 조회(select) 작업에서는 트랜잭션을 명시적으로 걸 필요가 없다.  
하지만, 트랜잭션 내에서 동일한 select 작업이 2번 이상 실행되는 경우에 항상 같은 결과를 기대한다면,  
`Repeatable Read` 이상의 격리 수준이 필요하며, 이는 트랜잭션 범위 내에서만 가능하므로 트랜잭션이 필요하다.

<br>

### @Transactional(readOnly = true)를 사용하는 이유
1. 의도치 않은 데이터 변경 방지
   - JPA에서 변경 감지(Dirty Checking)가 비활성화되어, 조회 중 실수로 엔티티 값을 변경하더라도 DB에 반영되지 않는다.
2. 메모리 사용 최적화
   - JPA는 엔티티 변경 여부를 감지하기 위해 스냅샷을 저장하는데,
   - `readOnly=true`일 경우 스냅샷을 만들지 않아 메모리 사용이 줄어든다.
3. DB 부하 분산 가능
   - 적절한 라우팅을 통해 `readOnly=true`는 Slave DB로 유도하여 부하 분산이 가능하다.
4. 코드의 의도 명확화
   - 해당 메서드가 조회 전용 트랜잭션임을 명시함으로써 가독성이 향상되고, 유지보수 시 의도를 쉽게 파악할 수 있다.
 
