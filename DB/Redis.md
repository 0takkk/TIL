
## Redis
`Redis(Remote Dictionary Server)`는 오픈소스 기반의 인메모리 데이터 저장소이다.  
키-값(key-value) 구조를 기반으로 다양한 자료형을 지원하며, 빠른 속도와 풍부한 기능 덕분에 캐시, 세션 저장소, 실시간 순위표 등 다양한 분야에서 활용된다.

<br>

## Redis의 자료구조
Redis는 하나의 키에 하나의 데이터형을 매핑하는 단순한 구조를 갖고 있다.  
기본적으로 `String`, `Hash`, `List`, `Set`, `Sorted Set`과 같은 자료형을 지원하며, RedisJSON 모듈을 활용하면 `JSON` 구조도 저장할 수 있다.
![](https://i.imgur.com/IyLaL5K.png)

<br>

## Redis의 영속성
인메모리 기반의 저장소는 기본적으로 데이터를 디스크에 저장하지 않기 때문에, 서버가 종료되면 데이터가 모두 사라지는 문제가 있다. 이를 보완하기 위해 Redis는 `스냅샷(Snapshot)`과 `AOF(Append Only File)` 방식을 통해 영속성 기능을 제공한다.

> 영속성 : 프로그램이 종료되더라도 데이터가 유지되는 특성

<br>

### 스냅샷 (Snapshot)
`스냅샷` 방식은 메모리에 있는 전체 데이터를 주기적으로 디스크에 저장하는 방식이다.   
특정 시점의 상태를 그대로 저장하는 구조이기 때문에 '사진을 찍듯 저장한다'는 의미로 `스냅샷`이라 불린다.
- **장점**: 서버 재시작 시 전체 상태를 간단히 복원할 수 있어 빠르고 직관적이다.
- **단점**: 백업 주기 사이에 장애가 발생하면 그 사이의 데이터는 유실될 수 있다.

<br>

### AOF (Append Only File)
`AOF` 방식은 Redis가 처리한 모든 쓰기 명령어를 순차적으로 파일에 기록하여 복원 가능한 상태를 만든다.   
데이터 변경이 발생할 때마다 해당 명령어가 로그에 추가되며, 이를 통해 정밀한 복원이 가능하다.
- **장점**: 매우 높은 수준의 데이터 보존이 가능하며, 장애 발생 시 손실을 최소화할 수 있다.
- **단점**: 파일 크기가 크고, 모든 명령을 기록하기 때문에 `스냅샷` 방식보다 느릴 수 있다.

<br>

### 권장사항
`스냅샷`과 `AOF`를 함께 사용하는 것이 가장 안정적이다.  
`스냅샷`을 주기적으로 저장하고, 그 사이의 변경 사항은 `AOF`로 보완하면, 빠른 재기동과 높은 데이터 안정성을 동시에 확보할 수 있다.

<br>

## Redis 운영 시 주의사항
### 메모리 관리
Redis는 모든 데이터를 메모리에 저장하므로, 메모리 용량을 초과하면 성능 저하나 장애가 발생할 수 있다. 시스템 메모리를 초과할 경우 운영체제는 swap을 사용하게 되는데, 이는 디스크를 이용한 임시 저장 공간이기 때문에 속도가 매우 느려져 latency가 급격히 증가한다.

<br>

### O(N)의 명령어 사용 자제
Redis는 싱글 스레드로 동작하기 때문에 하나의 명령어가 오래 걸리면 전체 처리 속도가 느려진다. 따라서 `O(N)` 이상의 시간 복잡도를 가진 명령어 사용은 매우 주의해야 한다. 예를 들어 `KEYS *`, `FLUSHALL`, `LRANGE key 0 -1` 등의 명령어는 데이터 양이 많을수록 성능에 큰 영향을 미친다. 이런 명령어는 운영 중에는 가급적 사용을 피하고, 테스트 환경이나 데이터 양이 적을 때에만 사용해야 한다.

<br>

## 싱글 스레드인 레디스가 빠른 이유
Redis는 `싱글 스레드`로 동작함에도 불구하고 매우 빠른 성능을 자랑한다.   
그 이유는 여러 구조적, 기술적 요소에 기반한다.  
1. 모든 연산이 디스크가 아닌 메모리에서 수행되기 때문에 데이터 접근 속도가 빠르다.
2. Redis는 키-값 기반의 단순한 구조를 가지고 있으며, 내부적으로 해시 테이블을 사용하기 때문에 대부분의 조회 연산이 O(1)의 시간 복잡도를 갖는다.
3. Redis는 `논블로킹 I/O`와 `I/O 멀티플렉싱` 기반의 `이벤트 루프 아키텍처`를 사용한다. 이를 통해 하나의 스레드로도 여러 클라이언트의 요청을 효율적으로 처리할 수 있다.
4. 컨텍스트 스위칭이나 락(lock)과 같은 멀티스레딩 환경에서 발생할 수 있는 오버헤드가 없기 때문에, CPU 자원을 더욱 효율적으로 사용할 수 있다.
5. Redis는 특정 목적에 최적화된 자료구조(Sorted Set 등)를 제공하여 다양한 사용 시나리오에서 빠른 응답을 가능하게 한다.

<br>

## 이벤트 루프 기반 아키텍처
Redis의 고성능 비결 중 하나는 싱글 스레드 구조와 함께 사용하는 `이벤트 루프 기반 아키텍처`이다.   
이 구조는 `I/O 멀티플렉싱`과 `논블로킹 I/O`를 통해 많은 클라이언트의 요청을 효율적으로 처리한다.

### 핵심 구성
- `I/O 멀티플렉서`는 클라이언트 소켓을 논블로킹 모드로 관리하며, 읽기/쓰기 이벤트가 발생했을 때 이를 감지해 이벤트 큐에 추가한다.
- `Redis 엔진`은 이벤트 큐에서 하나씩 명령을 꺼내 실행하며, 명령 처리가 완료되면 결과를 클라이언트에게 응답한다.

![](https://i.imgur.com/fEiWCPN.png)

### 동작 흐름
1. 클라이언트들이 Redis 서버에 동시에 연결해 명령을 전송한다.
2. 이벤트 루프는 모든 클라이언트 소켓을 감시하고, 이벤트 발생 시 이를 큐에 등록한다.
3. Redis 엔진은 큐에 등록된 명령을 순차적으로 처리한다. 하나의 명령이 완료되면 다음 명령을 처리하는 방식으로 동작한다.
4. 처리된 결과는 I/O 멀티플렉서를 통해 해당 클라이언트에게 비동기적으로 전달된다.

이러한 구조 덕분에 Redis는 멀티스레드를 사용하지 않고도 수많은 요청을 빠르게 처리할 수 있다.
